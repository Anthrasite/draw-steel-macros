{ "_id": "lBfmIKZDFeOow27S", "name": "DoPowerRoll", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=lBfmIKZDFeOow27S\n//@name=DoPowerRoll\n//@img=icons/svg/dice-target.svg\ntry {\n  const activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\n  const powerRollStat = await game.macros.getName(`ValidateParameter`).execute({ name: `powerRollStat`, value: scope.powerRollStat, type: `string`, nullable: true });\n  const allowedEdgeBane = await game.macros.getName(`ValidateParameter`).execute({ name: `allowedEdgeBane`, value: scope.allowedEdgeBane, type: `object`, nullable: true });\n  const forceBlessingOfFate = await game.macros.getName(`ValidateParameter`).execute({ name: `forceBlessingOfFate`, value: scope.forceBlessingOfFate, type: `boolean`, nullable: true });\n  const forceCurseOfFate = await game.macros.getName(`ValidateParameter`).execute({ name: `forceCurseOfFate`, value: scope.forceCurseOfFate, type: `boolean`, nullable: true });\n\n  // Manually check if the \"characteristics\" attribute is defined, as this is one of the few macros also used by the GM\n  const isPC = activeActor && Object.hasOwn(activeActor.system.attributes, `characteristics`);\n  if (isPC)\n    await game.macros.getName(`ValidateActorAttributes`).execute({ activeActor });\n\n  // Calculate the default modifier based on the highest allowed characteristic of the power roll\n  let defaultValue = 2;\n  if (isPC)\n    defaultValue = powerRollStat ? await game.macros.getName(`GetHighestCharacteristic`).execute({ activeActor, powerRollStat })\n      : await game.macros.getName(`GetHighestCharacteristic`).execute({ activeActor });\n\n  // Show the modifier dialog\n  modifier = await game.macros.getName(`ShowSimpleInputDialog`).execute({ label: `Modifier`, defaultValue });\n  if (modifier === ``)\n    modifier = 0;\n\n  // Create the buttons and CSS for the edges and banes dialog\n  function getEdgeBaneLabel(eb) {\n    return eb === `db` ? `Double bane`\n      : eb === `b` ? `Bane`\n      : eb === `e` ? `Edge`\n      : eb === `de` ? `Double edge`\n      : `Normal roll`;\n  }\n\n  let ebButtons = {\n    db: { label: getEdgeBaneLabel(`db`), color: `#8B0000` },\n    b: { label: getEdgeBaneLabel(`b`), color: `#4D0000` },\n    n: { label: getEdgeBaneLabel(`n`), color: `#000000` },\n    e: { label: getEdgeBaneLabel(`e`), color: `#003300` },\n    de: { label: getEdgeBaneLabel(`de`), color: `#006400` }\n  };\n\n  // Remove any buttons that aren't allowed\n  if (allowedEdgeBane)\n    for (const ebButtonCode in ebButtons)\n      if (!allowedEdgeBane.includes(ebButtonCode))\n        ebButtons[ebButtonCode].disabled = true;\n\n  function getEdgeBaneButtonColor(button) {\n    return button.disabled ? `var(--color-text-dark-secondary)` : button.color;\n  }\n\n  const ebButtonStyles = `\n    <style>\n      .dialog-buttons {\n        white-space: nowrap;\n      }\n      button.db {\n        color: ${getEdgeBaneButtonColor(ebButtons.db)};\n      }\n      button.b {\n        color: ${getEdgeBaneButtonColor(ebButtons.b)};\n      }\n      button.n {\n        color: ${getEdgeBaneButtonColor(ebButtons.n)};\n      }\n      button.e {\n        color: ${getEdgeBaneButtonColor(ebButtons.e)};\n      }\n      button.de {\n        color: ${getEdgeBaneButtonColor(ebButtons.de)};\n      }\n    </style>`\n\n  // Show the edges and banes dialog\n  const edgeBane = await Dialog.wait({\n    title: `Edges & Banes`,\n    buttons: ebButtons,\n    content: ebButtonStyles,\n    default: `n`\n  });\n\n  // Perform the roll and calculate the tier\n  const plusTier = edgeBane === `de`;\n  const minusTier = edgeBane === `db`;\n  const edgeBaneModifier = edgeBane === `e` ? `+ 2`\n    : edgeBane === `b` ? `- 2`\n    : ``;\n\n  let rollBase = `2d10`;\n  if (forceBlessingOfFate || (isPC && (await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName: `blessingOfFate` }))?.value))\n    rollBase = `3d10k2`;\n  else if (forceCurseOfFate || (isPC && (await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName: `curseOfFate` }))?.value))\n    rollBase = `3d10kl2`;\n\n  const roll = await new Roll(`${rollBase} ${edgeBaneModifier} + ${modifier}`).evaluate();\n  const isCrit = roll.dice[0].total > 18;\n\n  let tier = roll.total < 12 ? 1\n    : roll.total < 17 ? 2\n    : 3;\n  if (plusTier & tier < 3)\n    tier++;\n  if (minusTier & tier > 1)\n    tier--;\n\n  if (roll.dice[0].total === 20) // Always get a tier 3 result on roll of 20\n    tier = 3;\n\n  // Display the roll\n  const flavorColor = tier === 1 ? `#800000`\n    : tier === 2 ? `#000000`\n    : `#008000`;\n  await game.macros.getName(`ShareRoll`).execute({\n    activeActor,\n    roll,\n    flavor: `<span style=\"color: ${flavorColor}; font-weight: bold;\">${isCrit ? `Critical success! ` : ``}Tier ${tier} </span>[${getEdgeBaneLabel(edgeBane)}]`\n  });\n\n  return { tier: tier, edge: edgeBane };\n}\ncatch (error) {\n  if (error.message !== `The Dialog was closed without a choice being made.`)\n    ui.notifications.error(error);\n  else\n    throw error;\n}" }
{ "_id": "SrhPDyZWudXBRmU6", "name": "GetAttribute", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=SrhPDyZWudXBRmU6\n//@name=GetAttribute\n//@img=icons/svg/dice-target.svg\nconst activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\nconst attributeName = await game.macros.getName(`ValidateParameter`).execute({ name: `attributeName`, value: scope.attributeName, type: `string` });\n\nreturn attributeName === `stamina` ? activeActor.system.health\n  : attributeName === `recoveries` ? activeActor.system.power\n  : attributeName === `tempStamina` ? activeActor.system.attributes.tempHealth\n  : activeActor.system.attributes[attributeName];" }
{ "_id": "EaepUHVgCtZ65Sih", "name": "GetCharacteristic", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=EaepUHVgCtZ65Sih\n//@name=GetCharacteristic\n//@img=icons/svg/dice-target.svg\nconst activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\nconst characteristicName = await game.macros.getName(`ValidateParameter`).execute({ name: `characteristicName`, value: scope.characteristicName, type: `string` });\n\nreturn Math.min(Math.max(activeActor.system.attributes.characteristics[characteristicName.toLowerCase()].value, -5), 5);" }
{ "_id": "FKAi1azHUJEo5Oyl", "name": "GetHighestCharacteristic", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=FKAi1azHUJEo5Oyl\n//@name=GetHighestCharacteristic\n//@img=icons/svg/dice-target.svg\nconst activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\nconst powerRollStat = await game.macros.getName(`ValidateParameter`).execute({ name: `powerRollStat`, value: scope.powerRollStat, type: `string`, nullable: true });\n\nlet highestValue = -5;\nconst currCharacteristics = activeActor.system.attributes.characteristics;\nfor (const [charName, char] of Object.entries(currCharacteristics))\n  if ((typeof(powerRollStat) === `undefined` || powerRollStat.toLowerCase().includes(charName)) && char.value > highestValue)\n    highestValue = char.value;\n\nreturn Math.min(highestValue, 5);" }
{ "_id": "GOv0CejB17b8LXMR", "name": "GetKitDamage", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=GOv0CejB17b8LXMR\n//@name=GetKitDamage\n//@img=icons/svg/dice-target.svg\nconst activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\nconst isMelee = await game.macros.getName(`ValidateParameter`).execute({ name: `isMelee`, value: scope.isMelee, type: `boolean` });\nconst tier = await game.macros.getName(`ValidateParameter`).execute({ name: `tier`, value: scope.tier, type: `number` });\n\nconst kitDamageGroupName = `kit${isMelee ? `Melee` : `Ranged`}Damage`;\nconst kitDamageAttributeName = `tier${tier}`;\n\nreturn Object.hasOwn(activeActor.system.attributes, kitDamageGroupName) ? activeActor.system.attributes[kitDamageGroupName][kitDamageAttributeName].value : 0;" }
{ "_id": "czRakNtrsZFDoWij", "name": "GetPersistentCost", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=czRakNtrsZFDoWij\n//@name=GetPersistentCost\n//@img=icons/svg/dice-target.svg\nconst activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\n\nconst persistentCostString = (await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName: `persistentCost` })).value;\nlet persistentCosts = {};\nif (persistentCostString)\n  for (const pc of persistentCostString.split(`;`)) {\n    const pcSplit = pc.split(`:`);\n    persistentCosts[pcSplit[0]] = Number(pcSplit[1]);\n  }\n\nreturn persistentCosts;" }
{ "_id": "SZdU9V0OWjs46fRF", "name": "GetUUID", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=SZdU9V0OWjs46fRF\n//@name=GetUUID\n//@img=icons/svg/dice-target.svg\nreturn `10000000-1000-4000-8000-100000000000`.replace(/[018]/g, c =>\n  (+c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> +c / 4).toString(16)\n);" }
{ "_id": "wxzRAVPDMEyIoFSg", "name": "ShareAbility", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=wxzRAVPDMEyIoFSg\n//@name=ShareAbility\n//@img=icons/svg/dice-target.svg\ntry {\n  const activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\n  await game.macros.getName(`ValidateActorAttributes`).execute({ activeActor });\n\n  const name = await game.macros.getName(`ValidateParameter`).execute({ name: `name`, value: scope.name, type: `string` });\n  const resourceCost = await game.macros.getName(`ValidateParameter`).execute({ name: `resourceCost`, value: scope.resourceCost, type: `number`, nullable: true });\n  const flavorText = await game.macros.getName(`ValidateParameter`).execute({ name: `flavorText`, value: scope.flavorText, type: `string`, nullable: true });\n  const description = await game.macros.getName(`ValidateParameter`).execute({ name: `description`, value: scope.description, type: `string`, nullable: true });\n  const type = await game.macros.getName(`ValidateParameter`).execute({ name: `type`, value: scope.type, type: `string` });\n  const keywords = await game.macros.getName(`ValidateParameter`).execute({ name: `keywords`, value: scope.keywords, type: `string`, nullable: true });\n  const isKit = await game.macros.getName(`ValidateParameter`).execute({ name: `isKit`, value: scope.isKit, type: `boolean`, nullable: true });\n  const distance = await game.macros.getName(`ValidateParameter`).execute({ name: `distance`, value: scope.distance, type: `string`, nullable: true });\n  const target = await game.macros.getName(`ValidateParameter`).execute({ name: `target`, value: scope.target, type: `string`, nullable: true });\n  const trigger = await game.macros.getName(`ValidateParameter`).execute({ name: `trigger`, value: scope.trigger, type: `string`, nullable: true });\n  const powerRollStat = await game.macros.getName(`ValidateParameter`).execute({ name: `powerRollStat`, value: scope.powerRollStat, type: `string`, nullable: true });\n  const tier1Effect = await game.macros.getName(`ValidateParameter`).execute({ name: `tier1Effect`, value: scope.tier1Effect, type: `string`, nullable: true });\n  const tier2Effect = await game.macros.getName(`ValidateParameter`).execute({ name: `tier2Effect`, value: scope.tier2Effect, type: `string`, nullable: true });\n  const tier3Effect = await game.macros.getName(`ValidateParameter`).execute({ name: `tier3Effect`, value: scope.tier3Effect, type: `string`, nullable: true });\n  const effect = await game.macros.getName(`ValidateParameter`).execute({ name: `effect`, value: scope.effect, type: `string`, nullable: true });\n  const extraResourceCost = await game.macros.getName(`ValidateParameter`).execute({ name: `extraResourceCost`, value: scope.extraResourceCost, type: `string`, nullable: true });\n  const extraResourceEffect = await game.macros.getName(`ValidateParameter`).execute({ name: `extraResourceEffect`, value: scope.extraResourceEffect, type: `string`, nullable: true });\n  const extraResourceCost2 = await game.macros.getName(`ValidateParameter`).execute({ name: `extraResourceCost2`, value: scope.extraResourceCost2, type: `string`, nullable: true });\n  const extraResourceEffect2 = await game.macros.getName(`ValidateParameter`).execute({ name: `extraResourceEffect2`, value: scope.extraResourceEffect2, type: `string`, nullable: true });\n  const persistentCost = await game.macros.getName(`ValidateParameter`).execute({ name: `persistentCost`, value: scope.persistentCost, type: `number`, nullable: true });\n  const persistentEffect = await game.macros.getName(`ValidateParameter`).execute({ name: `persistentEffect`, value: scope.persistentEffect, type: `string`, nullable: true });\n  const strainedEffect = await game.macros.getName(`ValidateParameter`).execute({ name: `strainedEffect`, value: scope.strainedEffect, type: `string`, nullable: true });\n\n  const getCostFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `getCostFunc`, value: scope.getCostFunc, type: `function`, nullable: true });\n  const beforeRollFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `beforeRollFunc`, value: scope.beforeRollFunc, type: `function`, nullable: true });\n  const getDamageFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `getDamageFunc`, value: scope.getDamageFunc, type: `function`, nullable: true });\n  const getExtraDamageFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `getExtraDamageFunc`, value: scope.getExtraDamageFunc, type: `function`, nullable: true });\n  const afterRollFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `afterRollFunc`, value: scope.afterRollFunc, type: `function`, nullable: true });\n  const extraResourceFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `extraResourceFunc`, value: scope.extraResourceFunc, type: `function`, nullable: true });\n  const onStrainedFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `onStrainedFunc`, value: scope.onStrainedFunc, type: `function`, nullable: true });\n\n  // Perform additional validation\n  if (name.includes(`:`) || name.includes(`;`))\n    throw `Error: name cannot include \":\" or \";\"`;\n  if (typeof(resourceCost) !== `undefined` && resourceCost === 0)\n    throw `Error: resourceCost cannot be 0`;\n  if (typeof(trigger) !== `undefined` && !type.toLowerCase().includes(`triggered`))\n    throw `Error: trigger can only be specified for triggered actions`;\n  if (typeof(powerRollStat) !== typeof(tier1Effect) || typeof(powerRollStat) !== typeof(tier2Effect) || typeof(powerRollStat) !== typeof(tier3Effect))\n    throw `Error: powerRollStat, tier1Effect, tier2Effect, and tier3Effect must be specified together`;\n  if (typeof(extraResourceCost) !== typeof(extraResourceEffect))\n    throw `Error: extraResourceCost and extraResourceEffect must be specified together`;\n  if (typeof(extraResourceCost) !== `undefined` && !/[1-9][0-9]*\\+?/.test(extraResourceCost))\n    throw `Error: extraResourceCost cannot be 0`;\n  if (typeof(extraResourceCost2) !== typeof(extraResourceEffect2))\n    throw `Error: extraResourceCost2 and extraResourceEffect2 must be specified together`;\n  if (typeof(extraResourceCost2) !== `undefined` && !/[1-9][0-9]*\\+?/.test(extraResourceCost2))\n    throw `Error: extraResourceCost2 cannot be 0`;\n  if ((typeof(persistentCost) !== `undefined` || typeof(persistentEffect) !== `undefined`) && (typeof(persistentCost) !== `number` || typeof(persistentEffect) !== `string`))\n    throw `Error: persistentCost and persistentEffect must be specified together`;\n  if (typeof(persistentCost) !== `undefined` && persistentCost === 0)\n    throw `Error: persistentCost cannot be 0`;\n\n  // Calculate values for showing the \"Use\" button\n  const buttonId = await game.macros.getName(`GetUUID`).execute();\n\n  const resource = await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName: `resource` });\n\n  const showUseButton = resourceCost || extraResourceCost || extraResourceCost2 || powerRollStat || beforeRollFunc || afterRollFunc;\n  const canUse = showUseButton && (typeof(resourceCost) === `undefined` || resource.value >= resourceCost);\n\n  // Calculate the colour for the ability type\n  const actionColor = type === `Main action` ? `rgb(166, 28, 0)`\n    : type === `Maneuver` ? `rgb(61, 133, 198)`\n    : type === `Triggered` ? `rgb(56, 118, 29)`\n    : type === `Free triggered` ? `rgb(191, 144, 0)`\n    : `black`;\n\n  // Define functions for highlighting any potencies or characteristics in power roll results\n  function highlightPotency(tierEffect) {\n    return tierEffect.replaceAll(/([MAIRP]\\s+<\\s+[A-Za-z0-9]+)/g, `<span style=\"color: white; background-color: black; padding: 0px 3px; border-radius: 3px; white-space: nowrap;\">$1</span>`);\n  }\n\n  function highlightCharacteristic(tierEffect) {\n    const spanOpen = `<span style=\"color: white; background-color: black; padding: 0px 2px; border-radius: 2px;\">`;\n    const spanClose = `</span>`;\n\n    return tierEffect.replaceAll(/(\\s)([MAIRP])([\\s,;])/g, `$1${spanOpen}$2${spanClose}$3`)\n      .replaceAll(/(\\s)([MAIRP])$/g, `$1${spanOpen}$2${spanClose}`);\n  }\n\n  // Define functions for processing ability text\n  function formatText(text) {\n    const formattedText = highlightPotency(text);\n    if (!text.startsWith(`<`))\n      return `<p>${formattedText}</p>`;\n    return formattedText;\n  }\n\n  function formatTextWithLabel(label, text) {\n    const formattedLabel = `<b>${label}: </b>`;\n    const formattedText = highlightPotency(text);\n\n    // If the text starts with <p>, insert the label at the beginning of the <p> tag\n    if (text.startsWith(`<p>`))\n      return `${formattedText.substring(0, 3)}${formattedLabel}${formattedText.substring(3)}`;\n    // If the text starts with another HTML element, add a new <p> tag containing the label before the element\n    else if (text.startsWith(`<`))\n      return `<p>${formattedLabel}</p>${formattedText}`;\n    // If the text doesn't contain HTML, surround the text with a <p> tag, with the label at the beginning\n    else\n      return `<p>${formattedLabel}${formattedText}</p>`;\n  }\n\n  function formatPowerRollEffect(effect) {\n    return highlightCharacteristic(highlightPotency(effect));\n  }\n\n  // Show the ability in the chat\n  await ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    flags: { \"core.canPopout\": true },\n    content:\n      `<h2 style=\"border-color: ${actionColor}; border-width: 2px;\">${name}${(resourceCost ? ` <span style=\"font-size: 80%; font-style: italic;\"> (${resourceCost} ${resource.label})</span>` : ``)}</h2>\n      ${(flavorText? `<p style=\"font-style: italic;\">${flavorText}</p>` : ``)}\n      <table style=\"border: 0px; table-layout: fixed;\">\n      ${(keywords ? `\n        <tr>\n          <td><b>Keywords:</b> ${keywords}</td>\n        </tr>\n      ` : ``)}\n        <tr>\n          <td><b>Type:</b> ${type}</td>\n        </tr>\n      ${(distance ? `\n        <tr>\n          <td><b>Distance:</b> ${distance}</td>\n        </tr>\n      ` : ``)}\n      ${(target ? `\n        <tr>\n          <td><b>Target:</b> ${target}</td>\n        </tr>\n      ` : ``)}\n      </table>\n      ${(description ? formatText(description) : ``)}\n      ${(trigger ? formatTextWithLabel(`Trigger`, trigger) : ``)}\n      ${(powerRollStat ? `\n        <p style=\"font-weight: bold;\">Power Roll + ${powerRollStat}:</p>\n        <table style=\"border: 0; background: rgba(0, 0, 0, 0);\">\n          <tbody>\n            <tr style=\"background-color: rgba(0, 0, 0, 0);\">\n              <td style=\"white-space: nowrap; text-align: center; padding: 4px 0 0 0; vertical-align: top;\">\n                <div style=\"padding: 0 2px; border: 1px solid black; border-radius: 4px;\"><b>â‰¤11</b></div>\n              </td>\n              <td style=\"line-height: 1.3; padding: 4px 0 0 8px; width: 100%;\">${formatPowerRollEffect(tier1Effect)}</td>\n            </tr>\n            <tr style=\"background-color: rgba(0, 0, 0, 0);\">\n              <td style=\"white-space: nowrap; text-align: center; padding: 4px 0 0 0; vertical-align: top; margin-right: 20px;\">\n                <div style=\"padding: 0 2px; border: 1px solid black; border-radius: 4px;\"><b>12-16</b></div>\n              </td>\n              <td style=\"line-height: 1.3; padding: 4px 0 0 8px; width: 100%;\">${formatPowerRollEffect(tier2Effect)}</td>\n            </tr>\n            <tr style=\"background-color: rgba(0, 0, 0, 0);\">\n              <td style=\"white-space: nowrap; text-align: center; padding: 4px 0 0 0; vertical-align: top;\">\n                <div style=\"padding: 0 2px; border: 1px solid black; border-radius: 4px;\"><b>17+</b></div>\n              </td>\n              <td style=\"line-height: 1.3; padding: 4px 0 0 8px; width: 100%;\">${formatPowerRollEffect(tier3Effect)}</td>\n            </tr>\n          </tbody>\n        </table>\n      ` : ``)}\n      ${(effect ? formatTextWithLabel(`Effect`, effect) : ``)}\n      ${(strainedEffect ? formatTextWithLabel(`Strained`, strainedEffect) : ``)}\n      ${(persistentCost ? formatTextWithLabel(`Persistent ${persistentCost}`, persistentEffect) : ``)}\n      ${(extraResourceCost ? formatTextWithLabel(`Spend ${extraResourceCost} ${resource.label}`, extraResourceEffect) : ``)}\n      ${(extraResourceCost2 ? formatTextWithLabel(`Spend ${extraResourceCost2} ${resource.label}`, extraResourceEffect2) : ``)}\n      ${(showUseButton ? `<button id=\"${buttonId}\">${(canUse ? `Use` : `Not enough ${resource.label}`)}</button>` : ``)}`\n  });\n\n  // Register event for the \"Use\" button\n  if (showUseButton) {\n    $(document).on(`click`, `#${buttonId}`, async function() {\n      const button = $(this);\n      await game.macros.getName(`UseAbility`).execute({\n        activeActor,\n        button,\n        name,\n        keywords,\n        isKit,\n        resourceCost,\n        extraResourceCost,\n        extraResourceCost2,\n        persistentCost,\n        powerRollStat,\n        tier1Effect,\n        tier2Effect,\n        tier3Effect,\n        getCostFunc,\n        beforeRollFunc,\n        getDamageFunc,\n        getExtraDamageFunc,\n        afterRollFunc,\n        extraResourceFunc,\n        onStrainedFunc\n      });\n    });\n  }\n}\ncatch (error) {\n  ui.notifications.error(error);\n}" }
{ "_id": "aUX7yxzO8WBIhCKP", "name": "ShareFeature", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=aUX7yxzO8WBIhCKP\n//@name=ShareFeature\n//@img=icons/svg/dice-target.svg\ntry {\n  const activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\n  await game.macros.getName(`ValidateActorAttributes`).execute({ activeActor });\n\n  const name = await game.macros.getName(`ValidateParameter`).execute({ name: `name`, value: scope.name, type: `string` });\n  const description = await game.macros.getName(`ValidateParameter`).execute({ name: `description`, value: scope.description, type: `string` });\n  const source = await game.macros.getName(`ValidateParameter`).execute({ name: `source`, value: scope.source, type: `string` });\n\n  const onUseFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `onUseFunc`, value: scope.onUseFunc, type: `function`, nullable: true });\n\n  // Calculate values for showing the \"Use\" button\n  const buttonId = await game.macros.getName(`GetUUID`).execute();\n\n  // Define function for highlighting any potencies in ability descriptions\n  function highlightPotency(description) {\n    return description.replaceAll(/([MAIRP]\\s+<\\s+[A-Za-z0-9]+)/g, `<span style=\"color: white; background-color: black; padding: 0px 3px; border-radius: 3px; white-space: nowrap;\">$1</span>`);\n  }\n\n  function formatText(text) {\n    const formattedText = highlightPotency(text);\n    if (!text.startsWith(`<`))\n      return `<p>${formattedText}</p>`;\n    return formattedText;\n  }\n\n  // Show the ability in the chat\n  await ChatMessage.create({\n    user: game.user._id,\n    speaker: ChatMessage.getSpeaker(),\n    flags: { \"core.canPopout\": true },\n    content:\n      `<h2 style=\"border-color: black; border-width: 2px;\">${name} <span style=\"font-size: 80%; color: gray;\"> [${source}]</span></h2>\n      ${formatText(description)}\n      ${(onUseFunc ? `<button id=\"${buttonId}\">Use</button>` : ``)}`\n  });\n\n  // Register event for the \"Use\" button\n  if (onUseFunc) {\n    $(document).on(`click`, `#${buttonId}`, async function() {\n      await onUseFunc();\n\n      // Disable this event and delete the button\n      $(this).off(`click`);\n      $(this).remove();\n    });\n  }\n}\ncatch (error) {\n  ui.notifications.error(error);\n}" }
{ "_id": "rJPRglQIz1eHFSab", "name": "ShareRoll", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=rJPRglQIz1eHFSab\n//@name=ShareRoll\n//@img=icons/svg/dice-target.svg\nconst activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\nconst roll = await game.macros.getName(`ValidateParameter`).execute({ name: `roll`, value: scope.roll, type: `object` });\nconst flavor = await game.macros.getName(`ValidateParameter`).execute({ name: `flavor`, value: scope.flavor, type: `string` });\n\nconst message = await roll.toMessage({\n  speaker: ChatMessage.implementation.getSpeaker({ actor: activeActor }),\n  flavor\n});\nif (game.dice3d && roll.dice.length > 0)\n  await game.dice3d.waitFor3DAnimationByMessageID(message.id);" }
{ "_id": "96WYstdKircGE5Th", "name": "ShowPersistentCostDialog", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=96WYstdKircGE5Th\n//@name=ShowPersistentCostDialog\n//@img=icons/svg/dice-target.svg\nconst activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\nconst label = await game.macros.getName(`ValidateParameter`).execute({ name: `label`, value: scope.label, type: `string` });\nconst resourceLabel = await game.macros.getName(`ValidateParameter`).execute({ name: `resourceLabel`, value: scope.resourceLabel, type: `string` });\nconst selectByDefault = (await game.macros.getName(`ValidateParameter`).execute({ name: `selectByDefault`, value: scope.selectByDefault, type: `boolean`, nullable: true })) ?? false;\n\nconst persistentCosts = await game.macros.getName(`GetPersistentCost`).execute({ activeActor });\nif (!Object.keys(persistentCosts).length)\n  return undefined;\n\nlet persistCostOptions = ``;\nlet counter = 0;\nfor (const [abilityName, cost] of Object.entries(persistentCosts))\n  persistCostOptions += `\n    <div>\n      <input id=\"persistentCost${counter++}\" type=\"checkbox\" style=\"vertical-align: middle;\" name=\"persistentCosts\" value=\"${abilityName}\"${selectByDefault ? ` checked` : ``}/>\n      <label style=\"vertical-align: middle;\" for=\"persistentCost${counter}\">${abilityName} <i>(${cost} ${resourceLabel})</i></label>\n    </div>`;\n\nreturn await Dialog.prompt({\n  title: `Persistent cost`,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <fieldset>\n          <legend>${label}:</legend>\n          ${persistCostOptions}\n        </fieldset>\n      </div>\n    </form>`,\n  callback: html => html.find('input[name=\"persistentCosts\"]:checked').get().map(i => i.value)\n});" }
{ "_id": "AQTxaEf8itGUMpOR", "name": "ShowSimpleInputDialog", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=AQTxaEf8itGUMpOR\n//@name=ShowSimpleInputDialog\n//@img=icons/svg/dice-target.svg\nconst label = await game.macros.getName(`ValidateParameter`).execute({ name: `label`, value: scope.label, type: `string` });\nconst title = (await game.macros.getName(`ValidateParameter`).execute({ name: `label`, value: scope.title, type: `string`, nullable: true })) ?? label;\nconst allowNegative = (await game.macros.getName(`ValidateParameter`).execute({ name: `allowNegative`, value: scope.allowNegative, type: `boolean`, nullable: true })) ?? true;\nconst defaultValue = (await game.macros.getName(`ValidateParameter`).execute({ name: `defaultValue`, value: scope.defaultValue, type: `number`, nullable: true })) ?? 0;\nconst rejectClose = (await game.macros.getName(`ValidateParameter`).execute({ name: `rejectClose`, value: scope.rejectClose, type: `boolean`, nullable: true })) ?? true;\n\nreturn await Dialog.prompt({\n  title,\n  content: `\n    <form>\n      <div class=\"form-group\">\n        <label>${label}:</label>\n        <div class=\"form-fields\">\n          <input type=\"number\" onkeypress=\"return ((event.key >= '0' && event.key <= '9')${allowNegative ? ` || event.key === '-'` : ``})\" value=\"${defaultValue}\" autofocus onFocus=\"this.select()\"/>\n        </div>\n      </div>\n    </form>`,\n  rejectClose,\n  callback: html => html.find('input').val()\n});" }
{ "_id": "SQXPenBmpa0GCwc3", "name": "StartTurn", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=SQXPenBmpa0GCwc3\n//@name=StartTurn\n//@img=icons/svg/dice-target.svg\ntry {\n  const activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\n  await game.macros.getName(`ValidateActorAttributes`).execute({ activeActor });\n\n  const resourceRoll = (await game.macros.getName(`ValidateParameter`).execute({ name: `resourceRoll`, value: scope.resourceRoll, type: `string`, nullable: true })) ?? `1d3`;\n\n  const resourceAttribute = await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName: `resource` });\n\n  // If any persistent abilities are active, show a selector for those that should be maintained, and calculate the cost\n  let persistentCost = 0;\n  const currPersistentCosts = await game.macros.getName(`GetPersistentCost`).execute({ activeActor });\n  if (Object.keys(currPersistentCosts).length) {\n    if (resourceRoll.includes(`d`))\n      throw `Error: Handling of persistent effects with variable resource gain is not implemented`;\n\n    const abilitiesToMaintain = await game.macros.getName(`ShowPersistentCostDialog`).execute({ activeActor, label: `Persistent effects to maintain`, resourceLabel: resourceAttribute.label, selectByDefault: true });\n    for (const abilityName of abilitiesToMaintain)\n      persistentCost += currPersistentCosts[abilityName];\n\n    if (resourceRoll - persistentCost < 0) {\n      ui.notifications.error(`Not enough ${resourceAttribute.label} to maintain all persistent effects!`);\n      return;\n    }\n\n    for (const [abilityName, cost] of Object.entries(currPersistentCosts))\n      if (!abilitiesToMaintain.includes(abilityName))\n        await game.macros.getName(`UpdatePersistentCost`).execute({ activeActor, abilityName });\n  }\n\n  const roll = await new Roll(`${resourceAttribute.value} + ${resourceRoll}${persistentCost > 0 ? ` - ${persistentCost}` : ``}`).evaluate();\n  await game.macros.getName(`ShareRoll`).execute({\n    activeActor,\n    roll,\n    flavor: `${resourceAttribute.label.capitalize()} [Turn start]`\n  });\n\n  await game.macros.getName(`UpdateAttribute`).execute({ activeActor, attributeName: `resource`, value: roll.total });\n}\ncatch (error) {\n  if (error.message !== `The Dialog was closed without a choice being made.`)\n    ui.notifications.error(error);\n}" }
{ "_id": "inREdrJwhy1tXNak", "name": "UpdateAttribute", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=inREdrJwhy1tXNak\n//@name=UpdateAttribute\n//@img=icons/svg/dice-target.svg\nconst activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\nconst attributeName = await game.macros.getName(`ValidateParameter`).execute({ name: `attributeName`, value: scope.attributeName, type: `string` });\nconst value = await game.macros.getName(`ValidateParameter`).execute({ name: `value`, value: scope.value, type: `number` });\nconst isDelta = (await game.macros.getName(`ValidateParameter`).execute({ name: `isDelta`, value: scope.isDelta, type: `boolean`, nullable: true })) ?? false;\n\nconst attribute = await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName });\nif (!attribute)\n  return attribute;\n\nconst attributePath = attributeName === `stamina` ? `health`\n  : attributeName === `recoveries` ? `power`\n  : attributeName === `tempStamina` ? `attributes.tempHealth`\n  : `attributes.${attributeName}`;\n\nawait activeActor.update({ [`system.${attributePath}.value`]: isDelta ? attribute.value + value : value });\n\nreturn await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName });" }
{ "_id": "D6zoUBTvy8YqVhKc", "name": "UpdatePersistentCost", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=D6zoUBTvy8YqVhKc\n//@name=UpdatePersistentCost\n//@img=icons/svg/dice-target.svg\nconst activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\nconst abilityName = await game.macros.getName(`ValidateParameter`).execute({ name: `abilityName`, value: scope.abilityName, type: `string`, nullable: true });\nconst cost = await game.macros.getName(`ValidateParameter`).execute({ name: `cost`, value: scope.cost, type: `number`, nullable: true });\n\nif (cost && !abilityName)\n  throw `Error: Cost with no ability name`;\n\nlet value = ``;\nif (abilityName) {\n  const persistentCosts = await game.macros.getName(`GetPersistentCost`).execute({ activeActor });\n\n  if (cost)\n    persistentCosts[abilityName] = cost;\n  else\n    delete persistentCosts[abilityName];\n\n  value = Object.entries(persistentCosts).map(([k,v]) => `${k}:${v}`).join(`;`);\n}\n\nconst attributeName = `persistentCost`;\nconst attributePath = `system.attributes.${attributeName}.value`;\n\nawait activeActor.update({ [attributePath]: value });\n\nreturn await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName });" }
{ "_id": "C2f9bdcv7DKtawsp", "name": "UpdateTempStamina", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=C2f9bdcv7DKtawsp\n//@name=UpdateTempStamina\n//@img=icons/svg/dice-target.svg\nconst activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\nconst value = await game.macros.getName(`ValidateParameter`).execute({ name: `value`, value: scope.value, type: `number` });\n\nconst attributeName = `tempStamina`;\nconst tempStamina = await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName });\nif (value > tempStamina.value)\n  await game.macros.getName(`UpdateAttribute`).execute({ activeActor, attributeName, value });\n\nreturn await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName });" }
{ "_id": "UvSBFc1YuHe5kiDW", "name": "UseAbility", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=UvSBFc1YuHe5kiDW\n//@name=UseAbility\n//@img=icons/svg/dice-target.svg\ntry {\n  const activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\n  const button = await game.macros.getName(`ValidateParameter`).execute({ name: `button`, value: scope.button, type: `object` });\n\n  const name = await game.macros.getName(`ValidateParameter`).execute({ name: `name`, value: scope.name, type: `string` });\n  const resourceCost = await game.macros.getName(`ValidateParameter`).execute({ name: `resourceCost`, value: scope.resourceCost, type: `number`, nullable: true });\n  const extraResourceCost = await game.macros.getName(`ValidateParameter`).execute({ name: `extraResourceCost`, value: scope.extraResourceCost, type: `string`, nullable: true });\n  const extraResourceCost2 = await game.macros.getName(`ValidateParameter`).execute({ name: `extraResourceCost2`, value: scope.extraResourceCost2, type: `string`, nullable: true });\n  const persistentCost = await game.macros.getName(`ValidateParameter`).execute({ name: `persistentCost`, value: scope.persistentCost, type: `number`, nullable: true });\n  const powerRollStat = await game.macros.getName(`ValidateParameter`).execute({ name: `powerRollStat`, value: scope.powerRollStat, type: `string`, nullable: true });\n  const tier1Effect = await game.macros.getName(`ValidateParameter`).execute({ name: `tier1Effect`, value: scope.tier1Effect, type: `string`, nullable: true });\n  const tier2Effect = await game.macros.getName(`ValidateParameter`).execute({ name: `tier2Effect`, value: scope.tier2Effect, type: `string`, nullable: true });\n  const tier3Effect = await game.macros.getName(`ValidateParameter`).execute({ name: `tier3Effect`, value: scope.tier3Effect, type: `string`, nullable: true });\n  const keywords = (await game.macros.getName(`ValidateParameter`).execute({ name: `keywords`, value: scope.keywords, type: `string`, nullable: true })) ?? ``;\n  const isKit = (await game.macros.getName(`ValidateParameter`).execute({ name: `isKit`, value: scope.isKit, type: `boolean`, nullable: true })) ?? false;\n\n  const getCostFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `getCostFunc`, value: scope.getCostFunc, type: `function`, nullable: true });\n  const beforeRollFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `beforeRollFunc`, value: scope.beforeRollFunc, type: `function`, nullable: true });\n  const getDamageFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `getDamageFunc`, value: scope.getDamageFunc, type: `function`, nullable: true });\n  const getExtraDamageFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `getExtraDamageFunc`, value: scope.getExtraDamageFunc, type: `function`, nullable: true });\n  const afterRollFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `afterRollFunc`, value: scope.afterRollFunc, type: `function`, nullable: true });\n  const extraResourceFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `extraResourceFunc`, value: scope.extraResourceFunc, type: `function`, nullable: true });\n  const onStrainedFunc = await game.macros.getName(`ValidateParameter`).execute({ name: `onStrainedFunc`, value: scope.onStrainedFunc, type: `function`, nullable: true });\n\n  // Check the class to handle enable class-specific functionality\n  const className = (await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName: `class` })).value;\n  const isShadow = className.toLowerCase() === `shadow`;\n  const isTalent = className.toLowerCase() === `talent`;\n\n  // Determine if the ability can actually be used\n  const currResource = await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName: `resource` });\n  let actualResourceCost = resourceCost;\n\n  // Handle free persistent effects\n  const persistentCosts = await game.macros.getName(`GetPersistentCost`).execute({ activeActor });\n  if (Object.keys(persistentCosts).length && Object.hasOwn(persistentCosts, name)) {\n    const isPersistent = await Dialog.confirm({\n      title: `Persistent effect?`,\n      content: `<p>Are you using the persistent effect of ${name}?</p>`,\n      defaultYes: false\n    });\n    actualResourceCost = isPersistent ? 0 : resourceCost;\n  }\n\n  // Perform custom cost calculation if the function is specified\n  if (getCostFunc)\n    actualResourceCost = await getCostFunc(actualResourceCost);\n\n  // Handle Shadow ability cost reduction\n  let allowedEdgeBane = undefined;\n  if (isShadow && actualResourceCost && powerRollStat) {\n    const decreaseCost = await Dialog.confirm({\n      title: `Edge?`,\n      content: `<p>Will you have an edge on the power roll (against at least one target)?</p>`,\n      rejectClose: true\n    });\n\n    if (decreaseCost) {\n      --actualResourceCost;\n      allowedEdgeBane = [`de`, `e`];\n    }\n    else\n      allowedEdgeBane = [`n`, `b`, `db`];\n  }\n\n  // Show a warning and quit early if there isn't enough resource for this ability\n  if (actualResourceCost && currResource.value < actualResourceCost && !isTalent) {\n    ui.notifications.info(`Not enough ${currResource.label}!`);\n    return;\n  }\n\n  // Perform custom \"before roll\" functionality if the function is specified\n  if (beforeRollFunc)\n    await beforeRollFunc();\n\n  // Perform the power roll, if the ability has a power roll\n  let rollResult = undefined;\n  if (powerRollStat) {\n    rollResult = (await game.macros.getName(`DoPowerRoll`).execute({ activeActor, powerRollStat, allowedEdgeBane }));\n\n    // Calculate the damage of the ability\n    const effect = [ tier1Effect, tier2Effect, tier3Effect ][rollResult.tier - 1];\n    const matches = effect.match(/^(([0-9]+d[0-9]+)\\s+\\+\\s+)?([0-9]+)(\\s+\\+\\s+[MAIRPor,\\s]+)?\\s+((acid|cold|corruption|fire|holy|lightning|poison|psychic|sonic)\\s+)?damage/);\n    const effectDoesDamage = matches !== null;\n    const doesDamage = effectDoesDamage || getDamageFunc;\n\n    if (doesDamage) {\n      let diceDamage = undefined;\n      let constDamage = undefined;\n      let charDamageOptions = undefined;\n      let damageType = undefined;\n\n      // Perform custom damage calculation if the function is specified\n      if (getDamageFunc) {\n        let damage = await getDamageFunc(rollResult);\n        diceDamage = damage.diceDamage;\n        constDamage = damage.constDamage;\n        charDamageOptions = damage.charDamageOptions;\n        damageType = damage.damageType;\n      }\n      else {\n        diceDamage = matches[2];\n        constDamage = matches[3];\n        charDamageOptions = matches[4];\n        damageType = matches[6];\n      }\n\n      // Calculate the damage from the highest characteristic\n      let charDamage = undefined;\n      let maxCharName = undefined;\n      if (charDamageOptions) {\n        for (const [charName, char] of Object.entries(activeActor.system.attributes.characteristics))\n          if (charDamageOptions.indexOf(charName[0].toUpperCase()) >= 0 && (!maxCharName || char.value > charDamage)) {\n            maxCharName = charName;\n            charDamage = char.value;\n          }\n      }\n\n      // Calculate the damage from any weapon/implement enhancements\n      function canAddWeaponEnhancementDamage() {\n        return keywords.toLowerCase().includes(`weapon`);\n      }\n      function canAddImplementEnhancementDamage() {\n        return keywords.toLowerCase().includes(`magic`) || keywords.toLowerCase().includes(`psionic`);\n      }\n      async function getEnhancementDamage(isWeapon) {\n        return (await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName: isWeapon ? `weaponEnhancement` : `implementEnhancement` }))?.value ?? 0\n      }\n      const weaponEnhancementDamage = canAddWeaponEnhancementDamage() ? await getEnhancementDamage(true) : 0;\n      const implementEnhancementDamage = canAddImplementEnhancementDamage() ? await getEnhancementDamage(false) : 0;\n      const enhancementDamage = Math.max(weaponEnhancementDamage, implementEnhancementDamage);\n\n      // Calculate the damage from the kit (if this isn't a kit ability)\n      function canAddKitDamage(isMelee) {\n        return !isKit && keywords.toLowerCase().includes(isMelee ? `melee` : `ranged`) && keywords.toLowerCase().includes(`weapon`);\n      }\n      async function getKitDamage(isMelee) {\n        return await game.macros.getName(`GetKitDamage`).execute({ activeActor, isMelee, tier: rollResult.tier });\n      }\n      const meleeKitDamage = canAddKitDamage(true) ? await getKitDamage(true) : 0;\n      const rangedKitDamage = canAddKitDamage(false) ? await getKitDamage(false) : 0;\n      const kitDamage = Math.max(meleeKitDamage, rangedKitDamage);\n\n      // Calculate the damage from any bonus damage to magic abilities (prayers and enhancments)\n      function canAddMagicBonusDamage() {\n        return keywords.toLowerCase().includes(`magic`);\n      }\n      async function getMagicBonusDamage() {\n        return (await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName: `magicBonusDamage` }))?.value ?? 0\n      }\n      const magicDamageBonus = canAddMagicBonusDamage() ? await getMagicBonusDamage() : 0;\n\n      // Calculate the damage from any bonus damage to psionic abilities (augmentations)\n      function canAddPsionicBonusDamage() {\n        return keywords.toLowerCase().includes(`psionic`);\n      }\n      async function getPsionicBonusDamage() {\n        return (await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName: `psionicBonusDamage` }))?.value ?? 0\n      }\n      const psionicDamageBonus = canAddPsionicBonusDamage() ? await getPsionicBonusDamage() : 0;\n\n      // Perform custom extra damage calculation if the function is specified\n      let extraDamage = undefined;\n      if (getExtraDamageFunc)\n        extraDamage = await getExtraDamageFunc(rollResult);\n\n      let damageRollString = ``;\n      if (diceDamage)\n        damageRollString += diceDamage + ` + `;\n      damageRollString += constDamage;\n      if (charDamage)\n        damageRollString += ` + ` + charDamage + `[${maxCharName[0].toUpperCase()}]`;\n      if (enhancementDamage)\n        damageRollString += ` + ` + enhancementDamage + `[enh]`;\n      if (kitDamage)\n        damageRollString += ` + ` + kitDamage + `[kit]`;\n      if (magicDamageBonus)\n        damageRollString += ` + ` + magicDamageBonus + `[bon]`;\n      if (psionicDamageBonus)\n        damageRollString += ` + ` + psionicDamageBonus + `[bon]`;\n      if (extraDamage)\n        damageRollString += extraDamage;\n\n      const damageRoll = await new Roll(damageRollString).evaluate();\n      await game.macros.getName(`ShareRoll`).execute({\n        activeActor,\n        roll: damageRoll,\n        flavor: damageType ? `${damageType.capitalize()} damage` : `Damage`\n      });\n    }\n\n    // Determine if any surges should be used\n    const hasPotency = /([A-Z]\\s+<\\s+[A-Z0-9]+)/i.test(effect);\n    const surgeCount = (await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName: `surges` })).value;\n    if (doesDamage && surgeCount > 0 || hasPotency && surgeCount >= 2) {\n      let surgeButtons = {\n        z: { label: `0` },\n        d1: { label: `1 (damage)`, color: `darkred`, disabled: true },\n        d2: { label: `2 (damage)`, color: `darkred`, disabled: true },\n        p2: { label: `2 (potency)`, color: `darkblue`, disabled: true },\n        d3: { label: `3 (damage)`, color: `darkred`, disabled: true }\n      }\n      if (doesDamage) {\n        surgeButtons.d1.disabled = false;\n        if (surgeCount >= 3)\n          surgeButtons.d3.disabled = false;\n        if (surgeCount >= 2)\n          surgeButtons.d2.disabled = false;\n      }\n      if (hasPotency && surgeCount >= 2)\n        surgeButtons.p2.disabled = false;\n\n      function getSurgeButtonColor(button) {\n        return button.disabled ? `var(--color-text-dark-secondary)` : button.color;\n      }\n\n      const surgeButtonStyles = `\n        <style>\n          .dialog-buttons {\n            white-space: nowrap;\n          }\n          button.d1 {\n            color: ${getSurgeButtonColor(surgeButtons.d1)};\n          }\n          button.d2 {\n            color: ${getSurgeButtonColor(surgeButtons.d2)};\n          }\n          button.d3 {\n            color: ${getSurgeButtonColor(surgeButtons.d3)};\n          }\n          button.p2 {\n            color: ${getSurgeButtonColor(surgeButtons.p2)};\n          }\n        </style>`;\n\n      const surgesUsed = await Dialog.wait({\n        title: `Surges to use`,\n        buttons: surgeButtons,\n        content: surgeButtonStyles,\n        default: `z`,\n        close: () => { return 0; }\n      });\n\n      // If surges should be used, subtract the surges, and send an additional roll for surge damage if used for damage\n      if (surgesUsed && surgesUsed !== `z`) {\n        const damageSurges = surgesUsed.startsWith(`d`) ? Number(surgesUsed.substring(1)) : 0;\n        const potencySurges = surgesUsed.startsWith(`p`) ? Number(surgesUsed.substring(1)) : 0;\n\n        // Handle Shadow resource gain when using a surges for damage for the first time in a round\n        if (isShadow && damageSurges > 0) {\n          const firstSurge = await Dialog.confirm({\n            title: `First surge?`,\n            content: `<p>Is this the first surge used this round?</p>`,\n            defaultYes: false\n          });\n          if (firstSurge) {\n            const level = (await game.macros.getName(`GetAttribute`).execute({ activeActor, attributeName: `level` })).value;\n            const resourceGain = level >= 10 ? 3 : level >= 4 ? 2 : 1;\n            await game.macros.getName(`UpdateAttribute`).execute({ activeActor, attributeName: `resource`, value: resourceGain, isDelta: true });\n          }\n        }\n\n        if (damageSurges > 0) {\n          const characteristics = activeActor.system.attributes.characteristics;\n          const maxChar = Math.max(...(Object.keys(characteristics).map((key) => characteristics[key].value)));\n          const surgeDamage = (damageSurges * maxChar);\n          const surgeRoll = await new Roll(surgeDamage.toString()).evaluate();\n          await game.macros.getName(`ShareRoll`).execute({\n            activeActor,\n            roll: surgeRoll,\n            flavor: `Surge damage`\n          });\n        }\n\n        await game.macros.getName(`UpdateAttribute`).execute({ activeActor, attributeName: `surges`, value: -(damageSurges + potencySurges), isDelta: true });\n      }\n    }\n  }\n\n  // Perform custom \"after roll\" functionality if the function is specified\n  if (afterRollFunc)\n    await afterRollFunc(rollResult);\n\n  // Set the persistent cost, if the ability has a persistent cost\n  if (persistentCost) {\n    await game.macros.getName(`UpdatePersistentCost`).execute({ activeActor, abilityName: name, cost: persistentCost });\n  }\n\n  // Subtract the resource cost, if the ability has a resource cost\n  let totalResourceCost = actualResourceCost ?? 0;\n  if (actualResourceCost || extraResourceCost || extraResourceCost2) {\n    // Determine if extra resource should be used and use it if so\n    if (extraResourceCost || extraResourceCost2) {\n      let extraResourceUsed = 0;\n\n      async function getExtraResourceUsed(extraResourceCost) {\n        const isExtraResourceCostVariable = extraResourceCost.endsWith(`+`);\n        const minExtraResourceCost = Number(isExtraResourceCostVariable ? extraResourceCost.substring(0, extraResourceCost.length - 1) : extraResourceCost);\n\n        // If the extra resource ends with a \"+\", then a variable amount can be used\n        if (isExtraResourceCostVariable) {\n          let extraResourceUsed = 0;\n\n          if (currResource.value >= totalResourceCost + minExtraResourceCost || isTalent) {\n            extraResourceUsed = Number((await game.macros.getName(`ShowSimpleInputDialog`).execute({ title: `Extra ${currResource.label}`, label: `Extra ${currResource.label} to use`, defaultValue: minExtraResourceCost, allowNegative: false, rejectClose: false })) ?? 0);\n\n            // Ensure the minimum resource was used\n            if (extraResourceUsed > 0 && extraResourceUsed < minExtraResourceCost) {\n              ui.notifications.warn(`Extra effect requires at least ${minExtraResourceCost} ${currResource.label} to be used! No extra ${currResource.label} was used.`);\n              return 0;\n            }\n            // Ensure that the actor has enough resource\n            else if (currResource.value < totalResourceCost + extraResourceUsed && !isTalent) {\n              ui.notifications.warn(`Not enough ${currResource.label}! ${extraResourceUsed} ${currResource.label} will be used instead.`);\n              return currResource.value - totalResourceCost;\n            }\n          }\n\n          return extraResourceUsed;\n        }\n        // If the extra resource doesn't end with a \"+\", then exactly that amount must be used\n        else if (currResource.value >= totalResourceCost + minExtraResourceCost || isTalent)\n          return await Dialog.confirm({\n            title: `Extra ${currResource.label}`,\n            content: `<p>Use extra ${minExtraResourceCost} ${currResource.label}?</p>`,\n            defaultYes: false\n          }) ? minExtraResourceCost : 0;\n      }\n\n      if (extraResourceCost)\n        extraResourceUsed += await getExtraResourceUsed(extraResourceCost);\n      if (extraResourceCost2)\n        extraResourceUsed += await getExtraResourceUsed(extraResourceCost2);\n      totalResourceCost += extraResourceUsed;\n\n      // Perform custom extra resource functionality if the function is specified and extra resource was used\n      if (extraResourceFunc && extraResourceUsed > 0)\n        await extraResourceFunc(extraResourceUsed, rollResult);\n    }\n\n    if (totalResourceCost > 0) {\n      await game.macros.getName(`UpdateAttribute`).execute({ activeActor, attributeName: `resource`, value: -totalResourceCost, isDelta: true });\n    }\n  }\n\n  // Perform custom strained functionality if the function is specified and resource is negative\n  if (onStrainedFunc && currResource.value - totalResourceCost < 0)\n    await onStrainedFunc(rollResult);\n\n  // Disable this event and delete the button\n  button.off(`click`);\n  button.remove();\n}\ncatch (error) {\n  if (error.message !== `The Dialog was closed without a choice being made.`)\n    ui.notifications.error(error);\n}" }
{ "_id": "1JFEp3M9VhftSyuZ", "name": "ValidateActorAttributes", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=1JFEp3M9VhftSyuZ\n//@name=ValidateActorAttributes\n//@img=icons/svg/dice-target.svg\nconst activeActor = await game.macros.getName(`ValidateParameter`).execute({ name: `activeActor`, value: scope.activeActor, type: `object` });\n\nfunction validateHasOwn(obj, propName, activeActor, isGroup = false) {\n  if (!Object.hasOwn(obj, propName))\n    throw `Error: ${isGroup ? `Group` : `Attribute`} \"${propName}\" is not defined for actor \"${activeActor.name}\"`;\n}\n\nfunction validateIsType(obj, propName, type, activeActor) {\n  if (obj[propName].dtype.toLowerCase() !== type)\n    throw `Error: Attribute \"${propName}\" for actor \"${activeActor.name}\" does not have \"${type}\" type`;\n}\n\nfunction validateHasOwnOfType(obj, propName, type, activeActor) {\n  validateHasOwn(obj, propName, activeActor, false);\n  validateIsType(obj, propName, type, activeActor);\n}\n\nfunction validateIsTypeIfHasOwn(obj, propName, type, activeActor) {\n  if (Object.hasOwn(obj, propName))\n    validateIsType(obj,propName, type, activeActor);\n}\n\nfunction validateHasNumberWithValue(obj, propName, activeActor) {\n  validateHasOwnOfType(obj, propName, `number`, activeActor, false);\n  if (typeof(obj[propName].value) === `undefined`)\n    throw `Error: Attribute \"${propName}\" for actor \"${activeActor.name}\" has no value`;\n}\n\nfunction validateHasNonEmptyLabel(obj, propName, activeActor) {\n  if (typeof(obj[propName].label) === `undefined` || obj[propName].label === ``)\n    throw `Error: Attribute \"${propName}\" for actor \"${activeActor.name}\" has no label`;\n}\n\nif (!activeActor)\n  throw `Error: No token is selected`;\n\nfor (const attr of [`resource`, `surges`, `victories`, `level`, `tempHealth`, `xp`])\n  validateHasOwnOfType(activeActor.system.attributes, attr, `number`, activeActor);\nvalidateHasNonEmptyLabel(activeActor.system.attributes, `resource`, activeActor);\nfor (const attr of [`persistentCost`, `class`])\n  validateHasOwnOfType(activeActor.system.attributes, attr, `string`, activeActor);\n\nvalidateHasOwn(activeActor.system.groups, `characteristics`, activeActor, true);\nvalidateHasOwn(activeActor.system.attributes, `characteristics`, activeActor);\nfor (const attr of [`might`, `agility`, `intuition`, `reason`, `presence`])\n  validateHasNumberWithValue(activeActor.system.attributes.characteristics, attr, activeActor);\n\nif (Object.hasOwn(activeActor.system.groups, `kitMeleeDamage`)) {\n  validateHasOwn(activeActor.system.attributes, `kitMeleeDamage`, activeActor);\n  for (const attr of [`tier1`, `tier2`, `tier3`])\n    validateHasNumberWithValue(activeActor.system.attributes.kitMeleeDamage, attr, activeActor);\n}\n\nif (Object.hasOwn(activeActor.system.groups, `kitRangedDamage`)) {\n  validateHasOwn(activeActor.system.attributes, `kitRangedDamage`, activeActor);\n  for (const attr of [`tier1`, `tier2`, `tier3`])\n    validateHasNumberWithValue(activeActor.system.attributes.kitRangedDamage, attr, activeActor);\n}\n\nvalidateIsTypeIfHasOwn(activeActor.system.attributes, `weaponEnhancement`, `number`, activeActor);\nvalidateIsTypeIfHasOwn(activeActor.system.attributes, `implementEnhancement`, `number`, activeActor);\nvalidateIsTypeIfHasOwn(activeActor.system.attributes, `magicBonusDamage`, `number`, activeActor);\nvalidateIsTypeIfHasOwn(activeActor.system.attributes, `psionicBonusDamage`, `number`, activeActor);\nvalidateIsTypeIfHasOwn(activeActor.system.attributes, `recoveryValueOverride`, `number`, activeActor);\nvalidateIsTypeIfHasOwn(activeActor.system.attributes, `savingThrowBonus`, `number`, activeActor);\nvalidateIsTypeIfHasOwn(activeActor.system.attributes, `blessingOfFate`, `boolean`, activeActor);\nvalidateIsTypeIfHasOwn(activeActor.system.attributes, `curseOfFate`, `boolean`, activeActor);" }
{ "_id": "dlDYABs6ha9yUIOr", "name": "ValidateParameter", "scope": "global", "type": "script", "ownership": { "default": 0 }, "img": "icons/svg/dice-target.svg", "command": "//@id=dlDYABs6ha9yUIOr\n//@name=ValidateParameter\n//@img=icons/svg/dice-target.svg\nconst name = scope.name;\nconst value = scope.value;\nconst type = scope.type;\nconst nullable = scope.nullable ?? false;\n\nfunction throwError(name, type) {\n  throw `Error: ${name} is not a valid ${type}`;\n}\n\nfunction validateString(name, value) {\n  if (typeof(value) !== `string` || value.length === 0)\n    throwError(name, `non-empty string`);\n}\nfunction validateBoolean(name, value) {\n  if (typeof(value) !== `boolean`)\n    throwError(name, `boolean`);\n}\n\nvalidateString(`name`, name);\nvalidateString(`type`, type);\nvalidateBoolean(`boolean`, nullable);\n\nif (!nullable || typeof(value) !== `undefined`) {\n  if (type === `string`)\n    validateString(name, value);\n  else if (type === `boolean`)\n    validateBoolean(name, value);\n  else if (type === `number`) {\n    if (typeof(value) !== `number` || isNaN(value))\n      throwError(name, `number`);\n  }\n  else if (type === `function`) {\n    if (typeof(value) !== `function`)\n      throwError(name, `function`);\n  }\n  else if (type === `object`) {\n    if (typeof(value) !== `object`)\n      throwError(name, `object`);\n  }\n  else\n    throw `Error: Parameter type is unsupported`;\n}\n\nreturn value;" }
